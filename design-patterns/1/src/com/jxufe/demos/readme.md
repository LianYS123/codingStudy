将数组转为集合：new ArrayList(Arrays.asList(arr))
直接用Arrays.asList(arr) 生成的集合里面的元素不能修改
list.retainAll(list2); 计算两个集合的交集,并把计算结果存入list中，list2不会变

去重:
Set set = new HashSet(list);

构造代码块总是随着构造器的执行而执行,在构造方法之前执行

类的实例化顺序：
1. 执行静态块
2. 执行构造代码块
3. 执行构造器

类中的实例成员，等价于构造代码块
类中的静态成员，等价于静态块

类一加载，所有静态空间都立即分配了，但赋值操作会按顺序执行

线程题：
写两个线程，一个打印1~52，另一个打印A~Z，打印顺序12A34B...5152Z


### 面向对象三大特点：
封装、继承、多态
封装：隐藏复杂，暴露简单  隔离变化、提高代码重用性、保护数据(检查数据)
继承：提高代码重用性(如果仅仅是为了重用，可以优先考虑组合)、多态的前提
多态：
    多态的前提：继承
    多态的作用：提高代码扩展性
    多态的体现：向上转型
    多态的限制：向上转型时，子类独有的成员无法使用

### LinkedList 方法
addFirst()
addList() == add()
remove() 删除顶部元素，并返回
peek()   返回顶部元素
poll()

- Stack<T> 参数化类型
T 类型参数

wait() 释放cpu 释放锁 唤醒等待锁的线程(不会唤醒因为wait而阻塞的线程)
三种阻塞：sleep阻塞、wait阻塞、拿不到锁阻塞
所以每次自己wait() 之前 notifyAll() 唤醒其他锁

线程题：
    子线程循环10次，主线程循环100次，然后子线程循环10次，主线程循环100次，这样循环50次

子类的无参构造器默认调用父类的无参构造器，如果父类没有无参构造器，就会报错