1. 单一职责原则 （SRP：Single responsibility principle）
它规定一个类应该只有一个发生变化的原因。一个类只干一件事

2. 开闭原则：
对扩展开放，对修改关闭
不改变源代码的情况下增加功能

Car
    getPrice()

DiscountCar()
    getPrice(){
        super.getPrice() * 0.8
    }

a. 开发代码的程序员分为两种
作者(服务器程序员)
用户(客户端程序员)

3. 接口隔离原则：
使用多个专门的接口要比使用一个总接口好

interface Animal
 eat();
 fly();
 swim();
 ---->
interface Eatable.java
interface Flyable.java
interface Swimable.java

4. 依赖倒置：
dependencyreverse
上层不应该依赖下层，他们都应该依赖抽象
违反依赖倒置：每当下层变动是，上层也跟着变
什么是上层？什么是下层？ 调用别的方法的就是上层，被调用的就是下层

class Persion {
    public void feed(Animal an){
        ...
        an.eat();
    }
}
interface Animal {
    void eat();
}
class Dog extend Animal {
    void eat();
}

Persion p = new Persion();
p.feed(Dog);

//下层直接依赖上层是违反依赖倒置的
原来依赖的箭头往下指，现在箭头往上指：依赖倒置


类和类之间的关系有三种：依赖、继承、关联
继承：实线加空心三角 (虚线是接口)
依赖：虚线加箭头,B的方法里面用A,就是B依赖A
关联：菱形+线+箭头，(B里面实例化一个A)，两种
    组合：关系强，                          实心菱形
    聚合：关系落，聚在一起，可以分开再回来    空心菱形

5. 迪米特法则(最少知道原则)：
 一个类知道的越少越好，只和朋友通信
 什么是朋友？
 a. 类中的字段是朋友
 b. 方法的参数
 c. 方法的返回值
 d. 方法的实例化

6. 里氏替换原则：任何基类出现的地方，都能替换成子类
任何能使用父类对象的地方，都应该能透明地替换父类对象

方法重写，在子类和父类中，方法中出现了返回类型相同、方法参数相同、方法名相同的方法时，构成方法重写
方法重写的两个限制：(保证代码满足里氏替换原则)
子类重写父类方法时，子类方法的访问修饰符不能比父类的更严格
子类重写父类方法时，子类方法不能抛出比父类更多的异常

继承的作用是什么？
    提高代码重用性
    多态的前提
两个类能不能发生继承关系的依据是什么？
    主要看有没有"is a" 关系
    考虑子类对象替换了父类对象后，业务逻辑是否发生变化! 如果变化，则不能发生继承关系

7. 组合优于继承
继承就是一个类继承另一个类
类之间的关系：继承、依赖、关联(组合、聚合)： 

这里的组合优于继承其实是关联

//需求，制作一个集合，统计该集合曾经加过多少个元素。(不是统计某一个时刻集合有多少元素)

Set addAll()方法，添加一个集合

如果父类作者和子类作者不是一个人，就别继承(别随便继承别人的类)

jdk中的反例 Stack类继承了Vector类，导致Stack里面有get、remove 方法，不像一个栈


面向接口: 设计模式中上层对下层暴露的都是接口(工厂、公共方法)

1. 简单工厂模式
产品： 类
抽象产品： 抽象类、接口
作用：把具体产品的类型从客户端代码中解耦出来了
缺点：无法扩展

2. 工厂方法设计模式
所有工厂的名字都是趋向于稳定的，一般不会变(工厂名字是一种承诺，不应该被改变)
自己做的产品为什么要做工厂？因为要把自己做的产品融入这个体系里(提高扩展性)， 这个体系的其他方法可能用到工厂
缺点：如果有多个产品等级，工厂类就会爆炸式增长


3. 抽象工厂模式 (抽象是工厂名字的抽象)
和工厂的区别：一个工厂生产多个产品种类
优点：把工厂方法模式的工厂数量减少了。
抽象工厂中，可以生产多个产品，这些产品之间必须要有内在联系，同一个工厂中的产品都属于一个产品簇
产品簇：多个有内在联系或逻辑关系的产品，如：6mm螺丝和6mm螺母是一组产品簇
缺点：当产品等级发生变化时，都要引起以前工厂代码的修改，违反了“开闭原则”
当产品等级比较固定时，可以使用抽象工厂。

补全知识点:java类只能继承(Extends)一个类,可以实现(implements)多个接口,java接口可以继承(Extends)多个接口,不能实现(implements)任何接口

4. 原型模式：

protected 同一个包或不同包的子类中能使用

使用原型模式：
1). 必须让目标类实现Cloneable接口，该接口是一个标记接口(没有任何方法),作用是告诉jvm该类可以被克隆
2). 必须重写clone方法，把修饰符protected改为public
- 克隆时不会调用构造函数
- 如何实现克隆方法？ 直接复制内存中的二进制
- 克隆出来的两个对象地址不一致
- 克隆方法会破坏单例模式(反序列化也会破坏单例模式)
- 这种克隆方式为浅拷贝(把原对象的二进制原模原样复制，包括地址)

如何使用深克隆？
使用序列化 将类写入文件，在读出来
写内存里：ByteArrayOutputStream() -> 这个类往内存里写
读取 bb = out.toByteArray();
in = new ByteArrayInputStream(bb)

创建对象的四种方式：构造器、反射、序列化、克隆
