1. 单一职责原则 （SRP：Single responsibility principle）
它规定一个类应该只有一个发生变化的原因。一个类只干一件事

2. 开闭原则：
对扩展开放，对修改关闭
不改变源代码的情况下增加功能

Car
    getPrice()

DiscountCar()
    getPrice(){
        super.getPrice() * 0.8
    }

a. 开发代码的程序员分为两种
作者(服务器程序员)
用户(客户端程序员)

3. 接口隔离原则：
使用多个专门的接口要比使用一个总接口好

interface Animal
 eat();
 fly();
 swim();
 ---->
interface Eatable.java
interface Flyable.java
interface Swimable.java

4. 依赖倒置：
dependencyreverse
上层不应该依赖下层，他们都应该依赖抽象
违反依赖倒置：每当下层变动是，上层也跟着变
什么是上层？什么是下层？ 调用别的方法的就是上层，被调用的就是下层

class Persion {
    public void feed(Animal an){
        ...
        an.eat();
    }
}
interface Animal {
    void eat();
}
class Dog extend Animal {
    void eat();
}

Persion p = new Persion();
p.feed(Dog);

//下层直接依赖上层是违反依赖倒置的
原来依赖的箭头往下指，现在箭头往上指：依赖倒置


类和类之间的关系有三种：依赖、继承、关联
继承：实线加空心三角 (虚线是接口)
依赖：虚线加箭头,B的方法里面用A,就是B依赖A
关联：菱形+线+箭头，(B里面实例化一个A)，两种
    组合：关系强，                          实心菱形
    聚合：关系落，聚在一起，可以分开再回来    空心菱形

5. 迪米特法则(最少知道原则)：
 一个类知道的越少越好，只和朋友通信
 什么是朋友？
 a. 类中的字段是朋友
 b. 方法的参数
 c. 方法的返回值
 d. 方法的实例化

6. 里氏替换原则：任何基类出现的地方，都能替换成子类
任何能使用父类对象的地方，都应该能透明地替换父类对象

方法重写，在子类和父类中，方法中出现了返回类型相同、方法参数相同、方法名相同的方法时，构成方法重写
方法重写的两个限制：(保证代码满足里氏替换原则)
子类重写父类方法时，子类方法的访问修饰符不能比父类的更严格
子类重写父类方法时，子类方法不能抛出比父类更多的异常

继承的作用是什么？
    提高代码重用性
    多态的前提
两个类能不能发生继承关系的依据是什么？
    主要看有没有"is a" 关系
    考虑子类对象替换了父类对象后，业务逻辑是否发生变化! 如果变化，则不能发生继承关系

7. 组合优于继承
继承就是一个类继承另一个类
类之间的关系：继承、依赖、关联(组合、聚合)： 

这里的组合优于继承其实是关联

//需求，制作一个集合，统计该集合曾经加过多少个元素。(不是统计某一个时刻集合有多少元素)

Set addAll()方法，添加一个集合

如果父类作者和子类作者不是一个人，就别继承(别随便继承别人的类)

jdk中的反例 Stack类继承了Vector类，导致Stack里面有get、remove 方法，不像一个栈